<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>har_bal &#8212; Harmonic Balance Solvers 0.5b13 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5b13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for har_bal</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fftp</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="c1"># from scipy import pi, sin,cos</span>
<span class="c1"># import matplotlib.pyplot as plt</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;harmonic_balance_so&quot;</span><span class="p">,</span>
           <span class="s2">&quot;harmonic_deriv&quot;</span><span class="p">,</span>
           <span class="s2">&quot;somf&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="harmonic_balance_so"><a class="viewcode-back" href="../reference/harmonic_balance.html#har_bal.harmonic_balance_so">[docs]</a><span class="k">def</span> <span class="nf">harmonic_balance_so</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Harmonic balance solver for second order ODEs.</span>

<span class="sd">    Obtains the solution of a second order differential equation under the</span>
<span class="sd">    presumption that the solution is harmonic.</span>

<span class="sd">    Returns t (time), x (displacement), v (velocity), and a (acceletation)</span>
<span class="sd">    response of a second order linear ordinary differential</span>
<span class="sd">    equation defined by</span>
<span class="sd">    :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc: str</span>
<span class="sd">        name of function that returns second derivative given omega and</span>
<span class="sd">        \*kwargs</span>
<span class="sd">        :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)`</span>
<span class="sd">    omega:  float</span>
<span class="sd">        assumed fundamental response frequency.</span>
<span class="sd">    num_harmonics: int</span>
<span class="sd">        number of harmonics to presume. Constant term is always presumed.</span>
<span class="sd">    x0: ndarray</span>
<span class="sd">        n x m array where n is the number of equations and m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">        It is required that :math:`m = 1 + 2  num_{harmonics}`.</span>
<span class="sd">    method: str</span>
<span class="sd">        Name of optimization method to be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t, x, v, a : ndarrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    a) define a function that returns errors in time domain as vector</span>
<span class="sd">    b) define function to obtain velocity and accelerations from displacement</span>
<span class="sd">    and frequencies.</span>
<span class="sd">    c)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="harmonic_deriv"><a class="viewcode-back" href="../reference/harmonic_balance.html#har_bal.harmonic_deriv">[docs]</a><span class="k">def</span> <span class="nf">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Derivative of a harmonic function using frequency methods.</span>

<span class="sd">    Returns the derivatives of a harmonic function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    omega: float</span>
<span class="sd">        Fundamendal frequency, in rad/sec, of repeating signal</span>
<span class="sd">    r: array</span>
<span class="sd">        | Array of rows of time histories to take the derivative of.</span>
<span class="sd">        | The 1 axis (each row) corresponds to a time history.</span>
<span class="sd">        | The length of the time histories *must be an odd integer*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s: array</span>
<span class="sd">        array of function derivatives.</span>
<span class="sd">        The 1 axis (each row) corresponds to a time history.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    At this time, the length of the time histories *must be an odd integer*.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from har_bal import *</span>
<span class="sd">    &gt;&gt;&gt; import scipy as sp</span>
<span class="sd">    &gt;&gt;&gt; from scipy import pi,sin,cos</span>
<span class="sd">    &gt;&gt;&gt; f = 2</span>
<span class="sd">    &gt;&gt;&gt; omega = 2.*pi * f</span>
<span class="sd">    &gt;&gt;&gt; numsteps = 11</span>
<span class="sd">    &gt;&gt;&gt; t = sp.arange(0,1/omega*2*pi,1/omega*2*pi/numsteps)</span>
<span class="sd">    &gt;&gt;&gt; x = sp.array([sin(omega*t)])</span>
<span class="sd">    &gt;&gt;&gt; v = sp.array([omega*cos(omega*t)])</span>
<span class="sd">    &gt;&gt;&gt; states = sp.append(x,v,axis = 0)</span>
<span class="sd">    &gt;&gt;&gt; state_derives = harmonic_deriv(omega,states)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t,states.T,t,state_derives.T,&#39;x&#39;)</span>
<span class="sd">    [&lt;matplotlib.line...]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">omega_half</span> <span class="o">=</span> <span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="mi">2</span><span class="n">j</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">omega_whole</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">omega_half</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">omega_half</span><span class="p">)</span>
    <span class="n">r_freq</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">s_freq</span> <span class="o">=</span> <span class="n">r_freq</span> <span class="o">*</span> <span class="n">omega_whole</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">s_freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="somf"><a class="viewcode-back" href="../reference/harmonic_balance.html#har_bal.somf">[docs]</a><span class="k">def</span> <span class="nf">somf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Acceleration of second order linear matrix system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, v, F : arrays</span>
<span class="sd">        :math:`n\\times 1` arrays of current displacement, velocity, and Force.</span>
<span class="sd">    M, C, K : arrays</span>
<span class="sd">        Mass, damping, and stiffness matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array</span>
<span class="sd">        :math:`n\\times 1` acceleration vector</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import scipy as sp</span>
<span class="sd">    &gt;&gt;&gt; M = sp.array([[2,0],[0,1]])</span>
<span class="sd">    &gt;&gt;&gt; K = sp.array([[2,-1],[-1,3]])</span>
<span class="sd">    &gt;&gt;&gt; C = 0.01 * M + 0.01 * K</span>
<span class="sd">    &gt;&gt;&gt; x = sp.array([[1],[0]])</span>
<span class="sd">    &gt;&gt;&gt; v = sp.array([[0],[10]])</span>
<span class="sd">    &gt;&gt;&gt; F = v * 0.1</span>
<span class="sd">    &gt;&gt;&gt; a = somf(x, v, M, C, K, F)</span>
<span class="sd">    array([[-0.95],</span>
<span class="sd">       [ 0.6 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span> <span class="o">@</span> <span class="n">v</span> <span class="o">+</span> <span class="n">K</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">hb_so_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Array (vector) of hamonic balance second order algebraic errors.</span>

<span class="sd">    Given a set of second order equations</span>
<span class="sd">    :math:`\ddot{x} = f(x, \dot{x}, \omega, t)`</span>
<span class="sd">    calculate the error :math:`E = \ddot{x} - f(x, \dot{x}, \omega, t)`</span>
<span class="sd">    presuming that :math:`x` can be represented as a Fourier series, and thus</span>
<span class="sd">    :math:`\dot{x}` and :math:`\ddot{x}` can be obtained from the Fourier</span>
<span class="sd">    series representation of :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array</span>
<span class="sd">        x is an :math:`n \\times m` by 1 array of presumed displacements. It</span>
<span class="sd">        must be a &quot;list&quot; array (not a linear algebra vector). Here</span>
<span class="sd">        :math:`n` is the number of displacements and :math:`m` is the number of</span>
<span class="sd">        times per cycle at which the displacement is guessed (minimum of 3)</span>

<span class="sd">    **kwargs : string, float, variable</span>
<span class="sd">        **kwargs is a packed set of keyword arguments with 3 required</span>
<span class="sd">        arguments.</span>
<span class="sd">            1. `function`: a string name of the</span>
<span class="sd">            function which returned the numerically calculated acceleration.</span>

<span class="sd">            2. `omega`: which is the defined fundamental harmonic</span>
<span class="sd">            at which the is desired.</span>

<span class="sd">            3. `n_har`: an integer representing the number of harmonics. Note</span>
<span class="sd">            that `m` above is equal to 1 + 2 * `n_har`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e : array</span>
<span class="sd">        2d numpy vector array of numerical error of presumed solution(s) `x`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `function` and `omega` are not separately defined arguments so as to enable</span>
<span class="sd">    algebraic solver functions to call `hb_so_err` cleanly.</span>

<span class="sd">    The algorithm is as follows:</span>
<span class="sd">        1. The vector `x` is reshaped into an :math:`n` by :math:`m` array</span>
<span class="sd">        2. The velocity and accelerations are calculated in the same shape as</span>
<span class="sd">           `x` as `vel` and `accel`.</span>
<span class="sd">        3. Each column of `x` and `v` are sent with `t`, `omega`, and other</span>
<span class="sd">           `**kwargs** are sent to `function` one at a time with the results</span>
<span class="sd">           agregated into the columns of `accel_num`.</span>
<span class="sd">        4. The difference between `accel_num` and `accel` is reshaped to be</span>
<span class="sd">           :math:`n \\times m` by 1 and returned as the vector error used by</span>
<span class="sd">           the numerical algebraic equation solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_har</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_har&#39;</span><span class="p">]</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_har</span>
    <span class="n">vel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">accel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
    <span class="n">accel_num</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">accel</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">accel_num</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">function</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">vel</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">accel_num</span> <span class="o">-</span> <span class="n">accel</span>

    <span class="k">return</span> <span class="n">e</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">optimizer will actually be solver from scipy.optimize</span>
<span class="sd">from scipy.optimize</span>
<span class="sd">Say:</span>
<span class="sd">newton_krylov</span>
<span class="sd">broyden1</span>
<span class="sd">https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Run doctests.</span>

<span class="sd">    python (name of this file)  -v</span>
<span class="sd">    will test all of the examples in the help.</span>

<span class="sd">    Leaving off -v will run the tests without any output. Success will return</span>
<span class="sd">    nothing.</span>

<span class="sd">    See the doctest section of the python manual.</span>
<span class="sd">    https://docs.python.org/3.5/library/doctest.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># import vibration_toolbox as vtb</span>

    <span class="c1"># doctest.run_docstring_examples(frfest,globals(),optionflags=doctest.ELLIPSIS)</span>
    <span class="c1"># doctest.run_docstring_examples(asd,globals(),optionflags=doctest.ELLIPSIS)</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span>
                    <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Harmonic Balance Solvers</a></h1>



<p class="blurb">Harmonic Balance Solvers</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Joseph C. Slater.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>